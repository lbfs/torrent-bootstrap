use crate::bencode::{BencodeDictionary, BencodeError, BencodeErrorKind, BencodeList, BencodeToken, Parser};
use super::info::calculate_info_hash;
use super::error::{TorrentError, TorrentErrorKind};

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct Torrent {
    // We do not record outer properties as they are not relevant to this program.
    pub info: TorrentInfo,
    // Not a field in a torrent, but tracked here as it is needed for identification.
    pub info_hash: Vec<u8>
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct TorrentInfo {
    pub name: String,
    pub length: Option<u64>,
    pub attr: Option<Vec<u8>>,
    pub files: Option<Vec<TorrentFile>>,
    pub piece_length: u64,
    pub pieces: Vec<Vec<u8>>
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct TorrentFile {
    pub length: u64,
    pub path: Vec<String>,
    pub attr: Option<Vec<u8>>
}

impl TorrentFile {
    pub fn padding(&self) -> bool {
        if let Some(attr) = &self.attr {
            return attr.contains(&b'p')
        }
        
        return self.path.len() == 2 && 
            self.path[0] == ".pad" && self.path[1].chars().all(char::is_numeric)
    }
}

// Converter
impl Torrent {
    pub fn from_bytes(bytes: &[u8]) -> Result<Torrent, TorrentError> {
        let token = match Parser::decode(bytes) {
            Ok(token) => token,
            Err(err) => Err(TorrentError::new(TorrentErrorKind::MalformedData, err.message.to_string()))?,
        };

        if let BencodeToken::Dictionary(root) = token {
            return Torrent::evaluate_root(&root, bytes);
        }

        Err(TorrentError::new(TorrentErrorKind::MalformedData, "Unexpected token at root. Expected dictionary token".to_string()))
    }

    fn evaluate_root(root: &BencodeDictionary, bytes: &[u8]) -> Result<Torrent, TorrentError> {
        let info = root.find_dictionary_value(b"info")
            .map_err(Torrent::convert_error)?;

        // Get Info Hash
        let info_hash = calculate_info_hash(info, bytes);

        // Evaluate Info
        let info = Torrent::evaluate_info(info)?;

        Ok(Torrent {
            info,
            info_hash
        })        
    }

    fn evaluate_info(info: &BencodeDictionary) -> Result<TorrentInfo, TorrentError> {
        // https://github.com/BiglySoftware/BiglyBT/issues/1274
        let name_utf8 = info.find_string_value(b"name.utf-8")
            .map_err(Torrent::convert_error);

        let name = info.find_string_value(b"name")
            .map_err(Torrent::convert_error);

        let name = if name_utf8.is_ok() {
            name_utf8
        } else {
            name
        };

        let name = name?;

        let name = std::str::from_utf8(&name.value)
            .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Name is not a valid UTF-8 string at {}.", name.start_position)))?
            .to_string();

        // Validate Piece Length
        let pieces = &info.find_string_value(b"pieces")
            .map_err(Torrent::convert_error)?
            .value;

        if pieces.len() % 20 != 0 {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Pieces hashes are not evenly divisible by 20.".to_string()))?
        }

        let pieces = pieces
            .chunks(20)
            .map(|slice| slice.to_vec())
            .collect();

        // Convert Piece Length
        let piece_length = info.find_integer_value(b"piece length")
            .map_err(Torrent::convert_error)?;
        
        let piece_length = u64::try_from(piece_length.value)
            .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Could not convert integer value at position {} to unsigned 64-bit integer value.", piece_length.start_position)))?;

        // One or the other is required, but not both or neither.
        let length = info.find_integer_value(b"length");
        let files = info.find_list_value(b"files");
        
        if length.is_ok() && files.is_ok() {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Info contains length and file properties. Only one must be present.".to_string()))?
        }

        if length.is_err() && files.is_err() {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Info does not contain length or file properties. One must be present.".to_string()))?
        }

        let length = if let Ok(length) = length {
            let length = u64::try_from(length.value)
                .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Could not convert integer value at position {} to unsigned 64-bit integer value.", length.start_position)))?;

            Some(length)
        } else { None };

        let files = if let Ok(files) = files {
            let files = Torrent::evaluate_files(files)?;

            if files.is_empty() {
                Err(TorrentError::new(TorrentErrorKind::MalformedData, "Files has no entries. One file must be present.".to_string()))?
            }

            Some(files)
        } else { None };

        // Make sure calculated piece count matches number of hashes.
        let total_length = if let Some(files) = &files {
            files.iter().map(|file| file.length).sum()
        } else { 
            length.unwrap() 
        };

        if !Torrent::validate_piece_count_against_hash_count(total_length, piece_length, &pieces) {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Piece count does not fall with-in the expected piece boundary.".to_string()))?
        }

        // See if the attr property is set
        let attr = match info.find_string_value(b"attr") {
            Ok(local_attr) => {
                Some(local_attr.value.clone())
            },
            Err(_) => None
        };

        Ok(TorrentInfo {
            name,
            files,
            attr,
            length,
            piece_length,
            pieces
        })
    }

    fn evaluate_files(files: &BencodeList) -> Result<Vec<TorrentFile>, TorrentError> {
        let mut files_result: Vec<TorrentFile> = Vec::new(); 

        for file_entry in &files.value {
            match file_entry {
                BencodeToken::Dictionary(file) => {
                    let result = Torrent::evaluate_file(file)?;
                    files_result.push(result);
                },
                _ => {
                    Err(TorrentError::new(TorrentErrorKind::MalformedData, "Unexpected token in files list. Expected a dictionary token.".to_string()))?
                }
            }
        }

        Ok(files_result)
    }

    fn evaluate_file(file: &BencodeDictionary) -> Result<TorrentFile, TorrentError> {
        let length = file.find_integer_value(b"length")
            .map_err(Torrent::convert_error)?;

        let length = u64::try_from(length.value)
            .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Could not convert integer value at position {} to unsigned 64-bit integer value.", length.start_position)))?;

        // https://github.com/BiglySoftware/BiglyBT/issues/1274
        let paths_utf8 = file.find_list_value(b"path.utf-8")
            .map_err(Torrent::convert_error);

        let paths = file.find_list_value(b"path")
            .map_err(Torrent::convert_error);

        let paths = if paths_utf8.is_ok() {
            paths_utf8
        } else {
            paths
        };

        let paths = paths?;

        let mut result_paths: Vec<String> = Vec::new();

        for path_entry in &paths.value {
            match path_entry {
                BencodeToken::String(path) => {
                    let result = std::str::from_utf8(&path.value)
                        .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Path token is not a valid UTF-8 string at {}.", path.start_position)))?;

                    result_paths.push(result.to_string());
                },
                _ => {
                    Err(TorrentError::new(TorrentErrorKind::MalformedData, "Unexpected token in path list. Expected a string token.".to_string()))?
                }
            }
        }

        if result_paths.is_empty() {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "File cannot have an empty path.".to_string()))?
        }

        // File Attributes
        let attr = match file.find_string_value(b"attr") {
            Ok(local_attr) => {
                Some(local_attr.value.clone())
            },
            Err(_) => None
        };

        Ok(TorrentFile {
            length,
            attr,
            path: result_paths.into_iter().collect()
        })
    }

    fn convert_error(err: BencodeError) -> TorrentError {
        let kind = match err.kind {
            BencodeErrorKind::MalformedData => TorrentErrorKind::MalformedData
        };

        TorrentError::new(kind, err.message)
    }

    fn validate_piece_count_against_hash_count(total_length: u64, piece_length: u64, pieces: &Vec<Vec<u8>>) -> bool {
        use std::cmp::min;

        let mut remainder = total_length;
        let mut count = 0;

        while remainder > 0 {
            count += 1;
            remainder -= min(remainder, piece_length);
        }

        pieces.len() == count
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn from_bytes_valid_non_dictionary_token_should_fail() {
        let input = b"10:helloworld";
        let torrent = Torrent::from_bytes(input);
        assert!(torrent.is_err());
    }

    #[test]
    fn from_bytes_invalid_bencode_should_fail() {
        let input = b"x";
        let torrent = Torrent::from_bytes(input);
        assert!(torrent.is_err());
    }

    #[test]
    fn from_bytes_dictionary_with_missing_info_should_fail() {
        let input = b"de";
        let torrent = Torrent::from_bytes(input);
        assert!(torrent.is_err());
    }

    #[test]
    fn from_bytes_single_file_torrent_should_succeed() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
            0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72, 0x72, 0x65, 0x6E, 0x74,
            0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31, 0x33, 0x3A, 0x63, 0x72, 0x65, 0x61,
            0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32,
            0x30, 0x36, 0x32, 0x31, 0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64,
            0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61,
            0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32,
            0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A,
            0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61,
            0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        let actual = actual.unwrap();
        let expected = Torrent {
            info: TorrentInfo {
                name: "example.png".to_string(),
                length: Some(393339),
                files: None,
                attr: None,
                piece_length: 524288,
                pieces: vec![
                    vec![61, 3, 229, 89, 49, 68, 20, 82, 246, 47, 157, 161, 155, 97, 235, 212, 64, 88, 227, 255]
                ],
            },
            info_hash: vec![79, 24, 196, 139, 13, 130, 147, 71, 144, 199, 252, 22, 35, 74, 190, 56, 163, 8, 18, 123],
        };

        assert_eq!(expected, actual);
    }

    #[test]
    fn from_bytes_multiple_file_torrent_should_succeed() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
            0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72, 0x72, 0x65, 0x6E, 0x74,
            0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31, 0x33, 0x3A, 0x63, 0x72, 0x65, 0x61,
            0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32,
            0x30, 0x36, 0x32, 0x30, 0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64,
            0x35, 0x3A, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34, 0x3A, 0x70,
            0x61, 0x74, 0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E, 0x67, 0x65, 0x65, 0x64,
            0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x35, 0x37, 0x33, 0x33,
            0x38, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A,
            0x70, 0x65, 0x67, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A,
            0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38,
            0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD,
            0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4,
            0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F,
            0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        let actual = actual.unwrap();

        let expected = Torrent {
            info: TorrentInfo {
                name: "Example".to_string(),
                length: None,
                attr: None,
                files: Some(vec![
                    TorrentFile {
                        length: 262540,
                        attr: None,
                        path: vec!["1.png".to_string()],
                    },
                    TorrentFile {
                        length: 557338,
                        attr: None,
                        path: vec!["2.jpeg".to_string()],
                    },
                ]),
                piece_length: 524288,
                pieces: vec![
                    vec![205, 113, 172, 214, 185, 177, 13, 52, 20, 24, 149, 41, 222, 64, 164, 229, 154, 232, 64, 198],
                    vec![222, 220, 208, 9, 117, 139, 87, 43, 47, 57, 191, 94, 78, 142, 68, 176, 66, 206, 40, 67],
                ],
            },
            info_hash: vec![158, 107, 242, 157, 198, 208, 115, 71, 243, 8, 84, 55, 8, 17, 60, 86, 152, 141, 19, 186],
        };

        assert_eq!(expected, actual);
    }

    #[test]
    fn from_bytes_invalid_pieces_divisor_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65,
            0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70,
            0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x31, 0x3A, 0x3D, 0x3D, 0x3D, 0xE5,
            0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB,
            0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_length_and_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x34, 0x3A,
            0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32,
            0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65,
            0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52,
            0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_has_both_length_and_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E,
            0x67, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61,
            0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A, 0x70, 0x65, 0x67, 0x65,
            0x65, 0x65, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33,
            0x39, 0x33, 0x33, 0x33, 0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65,
            0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70,
            0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A,
            0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29,
            0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09,
            0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0,
            0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_unexpected_token_in_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x6A, 0x70,
            0x67, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78,
            0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34,
            0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73,
            0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14,
            0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE,
            0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E,
            0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_multiple_torrent_zero_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D,
            0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70,
            0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6,
            0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5,
            0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B,
            0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_multiple_torrent_empty_file_paths_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38,
            0x65, 0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x65, 0x65, 0x65, 0x34,
            0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A,
            0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29,
            0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09,
            0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0,
            0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_multiple_torrent_invalid_file_path_token_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x69, 0x31, 0x32, 0x33, 0x65, 0x65,
            0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35,
            0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74, 0x68,
            0x6C, 0x69, 0x34, 0x35, 0x36, 0x65, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E,
            0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65,
            0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71,
            0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40,
            0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B,
            0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE,
            0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_invalid_piece_count_to_hash_count_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E,
            0x67, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61,
            0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A, 0x70, 0x65, 0x67, 0x65,
            0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78,
            0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x38, 0x31, 0x39,
            0x39, 0x32, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73,
            0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14,
            0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE,
            0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E,
            0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_name_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A,
            0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1,
            0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    
    #[test]
    fn from_bytes_invalid_utf8_name_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x32, 0x30, 0x3A, 0x3D,
            0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B,
            0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x31, 0x32, 0x3A, 0x70, 0x69,
            0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35,
            0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14,
            0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3,
            0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_pieces_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65,
            0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_piece_length_is_missing_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65,
            0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x36, 0x3A,
            0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5,
            0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB,
            0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_piece_length_is_not_valid_unsigned_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65, 0x34, 0x3A,
            0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A,
            0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1,
            0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_length_is_not_valid_unsigned_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65, 0x34, 0x3A,
            0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32,
            0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65,
            0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52,
            0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_file_length_is_not_valid_unsigned_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74,
            0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E, 0x67, 0x65, 0x65, 0x64,
            0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65,
            0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A,
            0x70, 0x65, 0x67, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65,
            0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A,
            0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69,
            0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9,
            0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A,
            0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F,
            0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65,
            0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_file_length_is_missing_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x34, 0x3A, 0x70, 0x61, 0x74,
            0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E, 0x67, 0x65, 0x65, 0x64,
            0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A,
            0x70, 0x65, 0x67, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65,
            0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A,
            0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69,
            0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9,
            0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A,
            0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F,
            0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65,
            0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_file_path_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x65,
            0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x35,
            0x37, 0x33, 0x33, 0x38, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D,
            0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70,
            0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6,
            0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5,
            0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B,
            0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_file_path_is_invalid_utf8_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC,
            0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4,
            0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57,
            0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28,
            0x43, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61,
            0x74, 0x68, 0x6C, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1,
            0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8,
            0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39,
            0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65,
            0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78, 0x61,
            0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65,
            0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32,
            0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34,
            0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18,
            0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC,
            0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E,
            0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_nonstandard_name_and_path_utf8_extension_should_succeed() {
        // The standard name and path fields have been filled with garbage information.
        // This way we can validate if the utf-8 fields are truly being read.
        let input = vec![
            0x64, 0x38, 0x3A, 0x61, 0x6E, 0x6E, 0x6F, 0x75, 0x6E, 0x63, 0x65, 0x35,
            0x39, 0x3A, 0x64, 0x68, 0x74, 0x3A, 0x2F, 0x2F, 0x37, 0x35, 0x37, 0x46,
            0x33, 0x46, 0x33, 0x30, 0x36, 0x38, 0x30, 0x44, 0x45, 0x41, 0x35, 0x36,
            0x38, 0x37, 0x34, 0x43, 0x35, 0x43, 0x41, 0x30, 0x42, 0x34, 0x42, 0x43,
            0x39, 0x33, 0x46, 0x41, 0x35, 0x41, 0x35, 0x38, 0x33, 0x34, 0x32, 0x34,
            0x2E, 0x64, 0x68, 0x74, 0x2F, 0x61, 0x6E, 0x6E, 0x6F, 0x75, 0x6E, 0x63,
            0x65, 0x37, 0x3A, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x30, 0x3A,
            0x31, 0x33, 0x3A, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x75,
            0x74, 0x66, 0x2D, 0x38, 0x30, 0x3A, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65,
            0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x31, 0x35, 0x3A, 0x42, 0x69,
            0x67, 0x6C, 0x79, 0x42, 0x54, 0x2F, 0x33, 0x2E, 0x38, 0x2E, 0x30, 0x2E,
            0x32, 0x31, 0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E,
            0x20, 0x64, 0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x31, 0x37,
            0x37, 0x38, 0x31, 0x30, 0x65, 0x38, 0x3A, 0x65, 0x6E, 0x63, 0x6F, 0x64,
            0x69, 0x6E, 0x67, 0x35, 0x3A, 0x55, 0x54, 0x46, 0x2D, 0x38, 0x34, 0x3A,
            0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A, 0x66, 0x69, 0x6C, 0x65, 0x73,
            0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x32,
            0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74, 0x68,
            0x6C, 0x31, 0x30, 0x3A, 0x57, 0x52, 0x4F, 0x4E, 0x47, 0x5F, 0x50, 0x41,
            0x54, 0x48, 0x65, 0x31, 0x30, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x75,
            0x74, 0x66, 0x2D, 0x38, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E, 0x67,
            0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69,
            0x35, 0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74,
            0x68, 0x6C, 0x31, 0x30, 0x3A, 0x57, 0x52, 0x4F, 0x4E, 0x47, 0x5F, 0x50,
            0x41, 0x54, 0x48, 0x65, 0x31, 0x30, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x2E,
            0x75, 0x74, 0x66, 0x2D, 0x38, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A, 0x70,
            0x65, 0x67, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31,
            0x30, 0x3A, 0x57, 0x52, 0x4F, 0x4E, 0x47, 0x5F, 0x4E, 0x41, 0x4D, 0x45,
            0x31, 0x30, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 0x75, 0x74, 0x66, 0x2D,
            0x38, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x33, 0x32, 0x37, 0x36, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69,
            0x65, 0x63, 0x65, 0x73, 0x35, 0x32, 0x30, 0x3A, 0xA3, 0xEA, 0x41, 0x03,
            0xA4, 0x05, 0x9D, 0x08, 0xF5, 0xCD, 0xFB, 0x34, 0xA3, 0x22, 0x7E, 0xBC,
            0x8D, 0x48, 0xBB, 0x45, 0xF5, 0x36, 0x36, 0x3E, 0x0E, 0x07, 0xC6, 0x63,
            0x41, 0x36, 0xFC, 0x9A, 0xEA, 0x1F, 0x9A, 0x3B, 0x09, 0x20, 0x2C, 0xCD,
            0x37, 0xC7, 0xBF, 0x42, 0xA2, 0xB8, 0x5E, 0x21, 0x94, 0x6E, 0xF1, 0xE9,
            0xEB, 0x40, 0x06, 0x71, 0x48, 0x76, 0x4D, 0x26, 0xE8, 0x7E, 0xFA, 0x31,
            0xE0, 0xF0, 0x0E, 0xCB, 0x82, 0xCF, 0x73, 0xF2, 0x75, 0x3C, 0x29, 0xCB,
            0x13, 0x61, 0x31, 0x44, 0x7A, 0x1E, 0x57, 0x9B, 0xEC, 0x0B, 0x96, 0x51,
            0x25, 0x89, 0x38, 0x2A, 0x8A, 0x0B, 0x73, 0x76, 0xE2, 0xF6, 0xEE, 0x0F,
            0x14, 0x29, 0x1F, 0x09, 0xA3, 0x38, 0xA7, 0xE3, 0x55, 0x1A, 0xC7, 0x3D,
            0x87, 0xB2, 0x66, 0xEE, 0xBA, 0xC7, 0xE8, 0xB3, 0xF6, 0x31, 0xAE, 0xB6,
            0xBB, 0xBE, 0x03, 0xAE, 0x79, 0x02, 0x31, 0x05, 0xFC, 0xE0, 0x36, 0x53,
            0x9E, 0x60, 0x6D, 0xD4, 0xAC, 0xC2, 0xB2, 0x46, 0x7C, 0x34, 0xBD, 0xBF,
            0xE2, 0xEA, 0xA7, 0x3C, 0x92, 0x4D, 0x4C, 0xC6, 0xAC, 0xBC, 0x4E, 0x10,
            0xA3, 0xE7, 0xAE, 0x03, 0xD3, 0x7C, 0x49, 0xB4, 0xC9, 0xE2, 0x29, 0xB7,
            0x0D, 0x08, 0x1A, 0x01, 0x39, 0x05, 0xEF, 0xB2, 0xFA, 0x24, 0xCB, 0xD5,
            0x64, 0xC7, 0x15, 0x08, 0x05, 0x94, 0xF2, 0xF8, 0x31, 0x7D, 0x8D, 0xA3,
            0x36, 0x72, 0x13, 0xED, 0xDE, 0x6F, 0x89, 0xDE, 0xA8, 0x38, 0x83, 0xCF,
            0x7B, 0x28, 0xA8, 0x70, 0x51, 0x43, 0xFA, 0x62, 0xE2, 0xF5, 0x92, 0x31,
            0x7B, 0x5E, 0xB2, 0x97, 0x95, 0x64, 0x70, 0xAE, 0xE2, 0x40, 0x99, 0x36,
            0xDC, 0xA1, 0x8E, 0xC1, 0xDC, 0xC7, 0x4F, 0xA4, 0xF4, 0x24, 0x7A, 0x2A,
            0x5C, 0xBD, 0x43, 0x11, 0x78, 0x71, 0x34, 0x20, 0x95, 0x28, 0xD1, 0x10,
            0x39, 0x7B, 0x2A, 0x3B, 0x80, 0xE4, 0x58, 0xB1, 0x18, 0x9B, 0x30, 0x84,
            0x30, 0x9F, 0x8C, 0x86, 0x29, 0xA3, 0xF4, 0x56, 0xF3, 0x63, 0x7B, 0xC4,
            0x8E, 0xE3, 0x48, 0x8A, 0x5C, 0x42, 0x17, 0x61, 0x96, 0xB8, 0x78, 0x2C,
            0x94, 0x3A, 0x92, 0x6E, 0xE3, 0xC2, 0x2F, 0xB8, 0xCC, 0xA1, 0x31, 0x22,
            0xB1, 0xA4, 0x98, 0xD4, 0x67, 0x05, 0x07, 0xFF, 0x83, 0x0E, 0x18, 0xC5,
            0xDC, 0xA8, 0x1B, 0xFB, 0x0C, 0x75, 0x06, 0x31, 0xAB, 0x89, 0xC5, 0x8D,
            0x59, 0xDA, 0x54, 0x12, 0x41, 0xDE, 0xEE, 0x4C, 0x9E, 0x78, 0xF2, 0x8F,
            0x20, 0x2F, 0x83, 0xF4, 0xF8, 0x2B, 0xA7, 0xAB, 0x11, 0x16, 0x7B, 0xD6,
            0x4F, 0x7D, 0x87, 0xAF, 0x53, 0xBA, 0x01, 0xBF, 0x82, 0x4A, 0x7D, 0x02,
            0xA9, 0x08, 0xA4, 0x51, 0x40, 0x39, 0x39, 0xA8, 0xD1, 0x10, 0xB7, 0x74,
            0xD2, 0x57, 0xF5, 0xCF, 0x0E, 0xFE, 0xDB, 0xB1, 0xED, 0xCE, 0xC6, 0xF7,
            0x03, 0x38, 0x26, 0xF4, 0x93, 0x3F, 0xF7, 0x9F, 0x5B, 0x4C, 0xB0, 0x72,
            0x75, 0xEC, 0xC4, 0xF2, 0xCF, 0x95, 0x0B, 0x1F, 0x31, 0xE8, 0xCC, 0x6A,
            0x52, 0x88, 0x7B, 0x7A, 0x8B, 0xEC, 0xCD, 0x33, 0x6C, 0x45, 0x35, 0xCB,
            0xD4, 0x00, 0xBB, 0xEF, 0x0C, 0x3F, 0x25, 0x38, 0x3D, 0xD6, 0x17, 0x57,
            0x60, 0x49, 0xCA, 0x0B, 0xA7, 0x1B, 0xD7, 0x1C, 0x16, 0xD0, 0x91, 0xE7,
            0x7C, 0x29, 0x76, 0x74, 0x78, 0xD8, 0xD8, 0xA9, 0x94, 0xED, 0x86, 0x37,
            0xC7, 0xE5, 0x85, 0x98, 0x21, 0x76, 0x7E, 0x9A, 0x9B, 0xF4, 0x21, 0x36,
            0x7F, 0xF1, 0x1E, 0x5C, 0xCA, 0x59, 0xB0, 0xF0, 0x8D, 0x65, 0x12, 0x2E,
            0xA7, 0x0E, 0xE0, 0x57, 0xCD, 0xC8, 0x70, 0x91, 0x11, 0x1A, 0x05, 0xA3,
            0xC5, 0xAA, 0x0F, 0x6C, 0x96, 0x81, 0xE5, 0x8B, 0x58, 0x02, 0xFA, 0xF4,
            0xB5, 0x17, 0xCB, 0x56, 0x61, 0x0D, 0xC0, 0xFF, 0xA1, 0xD4, 0x2E, 0xFF,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        let actual = actual.unwrap();

        assert_eq!("Example", actual.info.name);
        assert_eq!("1.png", actual.info.files.as_ref().unwrap()[0].path[0]);
        assert_eq!("2.jpeg", actual.info.files.as_ref().unwrap()[1].path[0]);
    }
}