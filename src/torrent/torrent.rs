use crate::bencode::{BencodeDictionary, BencodeError, BencodeErrorKind, BencodeList, BencodeToken, Parser};
use super::{calculate_info_hash, error::TorrentErrorKind, TorrentError};

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct Torrent {
    // We do not record outer properties as they are not relevant to this program.
    pub info: Info,
    // Not a field in a torrent, but tracked here as it is needed for identification.
    pub info_hash: Vec<u8>
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct Info {
    pub name: String,
    pub length: Option<u64>,
    pub files: Option<Vec<File>>,
    pub piece_length: u64,
    pub pieces: Vec<Vec<u8>>
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct File {
    pub length: u64,
    pub path: Vec<String>
}

// Converter
impl Torrent {
    pub fn from_bytes(bytes: &[u8]) -> Result<Torrent, TorrentError> {
        let token = match Parser::decode(bytes) {
            Ok(token) => token,
            Err(err) => Err(TorrentError::new(TorrentErrorKind::MalformedData, err.message.to_string()))?,
        };

        if let BencodeToken::Dictionary(root) = token {
            return Torrent::evaluate_root(&root, bytes);
        }

        Err(TorrentError::new(TorrentErrorKind::MalformedData, "Unexpected token at root. Expected dictionary token".to_string()))
    }

    fn evaluate_root(root: &BencodeDictionary, bytes: &[u8]) -> Result<Torrent, TorrentError> {
        let info = root.find_dictionary_value(b"info")
            .map_err(Torrent::convert_error)?;

        // Get Info Hash
        let info_hash = calculate_info_hash(info, bytes);

        // Evaluate Info
        let info = Torrent::evaluate_info(info)?;

        Ok(Torrent {
            info,
            info_hash
        })        
    }

    fn evaluate_info(info: &BencodeDictionary) -> Result<Info, TorrentError> {
        let name = info.find_string_value(b"name")
            .map_err(Torrent::convert_error)?;

        let name = std::str::from_utf8(&name.value)
            .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Name is not a valid UTF-8 string at {}.", name.start_position)))?
            .to_string();

        // Validate Piece Length
        let pieces = &info.find_string_value(b"pieces")
            .map_err(Torrent::convert_error)?
            .value;

        if pieces.len() % 20 != 0 {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Pieces hashes are not evenly divisible by 20.".to_string()))?
        }

        let pieces = pieces
            .chunks(20)
            .map(|slice| slice.to_vec())
            .collect();

        // Convert Piece Length
        let piece_length = info.find_integer_value(b"piece length")
            .map_err(Torrent::convert_error)?;
        
        let piece_length = u64::try_from(piece_length.value)
            .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Could not convert integer value at position {} to unsigned 64-bit integer value.", piece_length.start_position)))?;

        // One or the other is required, but not both or neither.
        let length = info.find_integer_value(b"length");
        let files = info.find_list_value(b"files");
        
        if length.is_ok() && files.is_ok() {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Info contains length and file properties. Only one must be present.".to_string()))?
        }

        if length.is_err() && files.is_err() {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Info does not contain length or file properties. One must be present.".to_string()))?
        }

        let length = if let Ok(length) = length {
            let length = u64::try_from(length.value)
                .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Could not convert integer value at position {} to unsigned 64-bit integer value.", length.start_position)))?;

            Some(length)
        } else { None };

        let files = if let Ok(files) = files {
            let files = Torrent::evaluate_files(files)?;

            if files.is_empty() {
                Err(TorrentError::new(TorrentErrorKind::MalformedData, "Files has no entries. One file must be present.".to_string()))?
            }

            Some(files)
        } else { None };

        // Make sure calculated piece count matches number of hashes.
        let total_length = if let Some(files) = &files {
            files.iter().map(|file| file.length).sum()
        } else { 
            length.unwrap() 
        };

        if !Torrent::validate_piece_count_against_hash_count(total_length, piece_length, &pieces) {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "Piece count does not fall with-in the expected piece boundary.".to_string()))?
        }

        Ok(Info {
            name,
            files,
            length,
            piece_length,
            pieces
        })
    }

    fn evaluate_files(files: &BencodeList) -> Result<Vec<File>, TorrentError> {
        let mut files_result: Vec<File> = Vec::new(); 

        for file_entry in &files.value {
            match file_entry {
                BencodeToken::Dictionary(file) => {
                    let result = Torrent::evaluate_file(file)?;
                    files_result.push(result);
                },
                _ => {
                    Err(TorrentError::new(TorrentErrorKind::MalformedData, "Unexpected token in files list. Expected a dictionary token.".to_string()))?
                }
            }
        }

        Ok(files_result)
    }

    fn evaluate_file(file: &BencodeDictionary) -> Result<File, TorrentError> {
        let length = file.find_integer_value(b"length")
            .map_err(Torrent::convert_error)?;

        let length = u64::try_from(length.value)
            .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Could not convert integer value at position {} to unsigned 64-bit integer value.", length.start_position)))?;

        let paths = file.find_list_value(b"path")
            .map_err(Torrent::convert_error)?;

        let mut result_paths: Vec<String> = Vec::new();

        for path_entry in &paths.value {
            match path_entry {
                BencodeToken::String(path) => {
                    let result = std::str::from_utf8(&path.value)
                        .map_err(|_| TorrentError::new(TorrentErrorKind::MalformedData, format!("Path token is not a valid UTF-8 string at {}.", path.start_position)))?;

                    result_paths.push(result.to_string());
                },
                _ => {
                    Err(TorrentError::new(TorrentErrorKind::MalformedData, "Unexpected token in path list. Expected a string token.".to_string()))?
                }
            }
        }

        if result_paths.is_empty() {
            Err(TorrentError::new(TorrentErrorKind::MalformedData, "File cannot have an empty path.".to_string()))?
        }

        Ok(File {
            length,
            path: result_paths.into_iter().collect()
        })
    }

    fn convert_error(err: BencodeError) -> TorrentError {
        let kind = match err.kind {
            BencodeErrorKind::MalformedData => TorrentErrorKind::MalformedData
        };

        TorrentError::new(kind, err.message)
    }

    fn validate_piece_count_against_hash_count(total_length: u64, piece_length: u64, pieces: &Vec<Vec<u8>>) -> bool {
        use std::cmp::min;

        let mut remainder = total_length;
        let mut count = 0;

        while remainder > 0 {
            count += 1;
            remainder -= min(remainder, piece_length);
        }

        pieces.len() == count
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn from_bytes_valid_non_dictionary_token_should_fail() {
        let input = b"10:helloworld";
        let torrent = Torrent::from_bytes(input);
        assert!(torrent.is_err());
    }

    #[test]
    fn from_bytes_invalid_bencode_should_fail() {
        let input = b"x";
        let torrent = Torrent::from_bytes(input);
        assert!(torrent.is_err());
    }

    #[test]
    fn from_bytes_dictionary_with_missing_info_should_fail() {
        let input = b"de";
        let torrent = Torrent::from_bytes(input);
        assert!(torrent.is_err());
    }

    #[test]
    fn from_bytes_single_file_torrent_should_succeed() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
            0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72, 0x72, 0x65, 0x6E, 0x74,
            0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31, 0x33, 0x3A, 0x63, 0x72, 0x65, 0x61,
            0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32,
            0x30, 0x36, 0x32, 0x31, 0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64,
            0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61,
            0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32,
            0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A,
            0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61,
            0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        let actual = actual.unwrap();
        let expected = Torrent {
            info: Info {
                name: "example.png".to_string(),
                length: Some(393339),
                files: None,
                piece_length: 524288,
                pieces: vec![
                    vec![61, 3, 229, 89, 49, 68, 20, 82, 246, 47, 157, 161, 155, 97, 235, 212, 64, 88, 227, 255]
                ],
            },
            info_hash: vec![79, 24, 196, 139, 13, 130, 147, 71, 144, 199, 252, 22, 35, 74, 190, 56, 163, 8, 18, 123],
        };

        assert_eq!(expected, actual);
    }

    #[test]
    fn from_bytes_multiple_file_torrent_should_succeed() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79,
            0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72, 0x72, 0x65, 0x6E, 0x74,
            0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31, 0x33, 0x3A, 0x63, 0x72, 0x65, 0x61,
            0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32,
            0x30, 0x36, 0x32, 0x30, 0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64,
            0x35, 0x3A, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34, 0x3A, 0x70,
            0x61, 0x74, 0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E, 0x67, 0x65, 0x65, 0x64,
            0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x35, 0x37, 0x33, 0x33,
            0x38, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A,
            0x70, 0x65, 0x67, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A,
            0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38,
            0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD,
            0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4,
            0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F,
            0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        let actual = actual.unwrap();

        let expected = Torrent {
            info: Info {
                name: "Example".to_string(),
                length: None,
                files: Some(vec![
                    File {
                        length: 262540,
                        path: vec!["1.png".to_string()],
                    },
                    File {
                        length: 557338,
                        path: vec!["2.jpeg".to_string()],
                    },
                ]),
                piece_length: 524288,
                pieces: vec![
                    vec![205, 113, 172, 214, 185, 177, 13, 52, 20, 24, 149, 41, 222, 64, 164, 229, 154, 232, 64, 198],
                    vec![222, 220, 208, 9, 117, 139, 87, 43, 47, 57, 191, 94, 78, 142, 68, 176, 66, 206, 40, 67],
                ],
            },
            info_hash: vec![158, 107, 242, 157, 198, 208, 115, 71, 243, 8, 84, 55, 8, 17, 60, 86, 152, 141, 19, 186],
        };

        assert_eq!(expected, actual);
    }

    #[test]
    fn from_bytes_invalid_pieces_divisor_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65,
            0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70,
            0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x31, 0x3A, 0x3D, 0x3D, 0x3D, 0xE5,
            0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB,
            0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_length_and_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x34, 0x3A,
            0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32,
            0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65,
            0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52,
            0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_has_both_length_and_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E,
            0x67, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61,
            0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A, 0x70, 0x65, 0x67, 0x65,
            0x65, 0x65, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33,
            0x39, 0x33, 0x33, 0x33, 0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65,
            0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70,
            0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A,
            0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29,
            0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09,
            0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0,
            0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_unexpected_token_in_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x6A, 0x70,
            0x67, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78,
            0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34,
            0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73,
            0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14,
            0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE,
            0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E,
            0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_multiple_torrent_zero_files_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D,
            0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70,
            0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6,
            0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5,
            0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B,
            0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_multiple_torrent_empty_file_paths_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38,
            0x65, 0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x65, 0x65, 0x65, 0x34,
            0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A,
            0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29,
            0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09,
            0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0,
            0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_multiple_torrent_invalid_file_path_token_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x69, 0x31, 0x32, 0x33, 0x65, 0x65,
            0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35,
            0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74, 0x68,
            0x6C, 0x69, 0x34, 0x35, 0x36, 0x65, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E,
            0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65,
            0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71,
            0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40,
            0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B,
            0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE,
            0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_invalid_piece_count_to_hash_count_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E,
            0x67, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61,
            0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A, 0x70, 0x65, 0x67, 0x65,
            0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78,
            0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x38, 0x31, 0x39,
            0x39, 0x32, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73,
            0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14,
            0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE,
            0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E,
            0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_name_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C,
            0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A,
            0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1,
            0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    
    #[test]
    fn from_bytes_invalid_utf8_name_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x32, 0x30, 0x3A, 0x3D,
            0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B,
            0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x31, 0x32, 0x3A, 0x70, 0x69,
            0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35,
            0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63,
            0x65, 0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14,
            0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3,
            0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_pieces_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65,
            0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_piece_length_is_missing_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x33, 0x39, 0x33, 0x33, 0x33,
            0x39, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65,
            0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x36, 0x3A,
            0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5,
            0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB,
            0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_piece_length_is_not_valid_unsigned_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65, 0x34, 0x3A,
            0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31,
            0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x32, 0x30, 0x3A,
            0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52, 0xF6, 0x2F, 0x9D, 0xA1,
            0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_length_is_not_valid_unsigned_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x31,
            0x31, 0x37, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x36, 0x3A,
            0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65, 0x34, 0x3A,
            0x6E, 0x61, 0x6D, 0x65, 0x31, 0x31, 0x3A, 0x65, 0x78, 0x61, 0x6D, 0x70,
            0x6C, 0x65, 0x2E, 0x70, 0x6E, 0x67, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65,
            0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32,
            0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65,
            0x73, 0x32, 0x30, 0x3A, 0x3D, 0x03, 0xE5, 0x59, 0x31, 0x44, 0x14, 0x52,
            0xF6, 0x2F, 0x9D, 0xA1, 0x9B, 0x61, 0xEB, 0xD4, 0x40, 0x58, 0xE3, 0xFF,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_file_length_is_not_valid_unsigned_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65, 0x34, 0x3A, 0x70, 0x61, 0x74,
            0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E, 0x67, 0x65, 0x65, 0x64,
            0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x2D, 0x31, 0x65,
            0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A,
            0x70, 0x65, 0x67, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65,
            0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A,
            0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69,
            0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9,
            0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A,
            0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F,
            0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65,
            0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_file_length_is_missing_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x34, 0x3A, 0x70, 0x61, 0x74,
            0x68, 0x6C, 0x35, 0x3A, 0x31, 0x2E, 0x70, 0x6E, 0x67, 0x65, 0x65, 0x64,
            0x34, 0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x36, 0x3A, 0x32, 0x2E, 0x6A,
            0x70, 0x65, 0x67, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65,
            0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A,
            0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69,
            0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9,
            0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A,
            0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F,
            0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65,
            0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_missing_file_path_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x65,
            0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x35,
            0x37, 0x33, 0x33, 0x38, 0x65, 0x65, 0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D,
            0x65, 0x37, 0x3A, 0x45, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32,
            0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
            0x68, 0x69, 0x35, 0x32, 0x34, 0x32, 0x38, 0x38, 0x65, 0x36, 0x3A, 0x70,
            0x69, 0x65, 0x63, 0x65, 0x73, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6,
            0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5,
            0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B,
            0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43,
            0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }

    #[test]
    fn from_bytes_file_path_is_invalid_utf8_should_fail() {
        let input = vec![
            0x64, 0x31, 0x30, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
            0x62, 0x79, 0x31, 0x38, 0x3A, 0x71, 0x42, 0x69, 0x74, 0x74, 0x6F, 0x72,
            0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x35, 0x2E, 0x30, 0x2E, 0x34, 0x31,
            0x33, 0x3A, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64,
            0x61, 0x74, 0x65, 0x69, 0x31, 0x37, 0x34, 0x32, 0x30, 0x36, 0x32, 0x30,
            0x38, 0x38, 0x65, 0x34, 0x3A, 0x69, 0x6E, 0x66, 0x6F, 0x64, 0x35, 0x3A,
            0x66, 0x69, 0x6C, 0x65, 0x73, 0x6C, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E,
            0x67, 0x74, 0x68, 0x69, 0x32, 0x36, 0x32, 0x35, 0x34, 0x30, 0x65, 0x34,
            0x3A, 0x70, 0x61, 0x74, 0x68, 0x6C, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC,
            0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4,
            0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57,
            0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28,
            0x43, 0x65, 0x65, 0x64, 0x36, 0x3A, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
            0x69, 0x35, 0x35, 0x37, 0x33, 0x33, 0x38, 0x65, 0x34, 0x3A, 0x70, 0x61,
            0x74, 0x68, 0x6C, 0x34, 0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1,
            0x0D, 0x34, 0x14, 0x18, 0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8,
            0x40, 0xC6, 0xDE, 0xDC, 0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39,
            0xBF, 0x5E, 0x4E, 0x8E, 0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65,
            0x65, 0x34, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x37, 0x3A, 0x45, 0x78, 0x61,
            0x6D, 0x70, 0x6C, 0x65, 0x31, 0x32, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65,
            0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x69, 0x35, 0x32, 0x34, 0x32,
            0x38, 0x38, 0x65, 0x36, 0x3A, 0x70, 0x69, 0x65, 0x63, 0x65, 0x73, 0x34,
            0x30, 0x3A, 0xCD, 0x71, 0xAC, 0xD6, 0xB9, 0xB1, 0x0D, 0x34, 0x14, 0x18,
            0x95, 0x29, 0xDE, 0x40, 0xA4, 0xE5, 0x9A, 0xE8, 0x40, 0xC6, 0xDE, 0xDC,
            0xD0, 0x09, 0x75, 0x8B, 0x57, 0x2B, 0x2F, 0x39, 0xBF, 0x5E, 0x4E, 0x8E,
            0x44, 0xB0, 0x42, 0xCE, 0x28, 0x43, 0x65, 0x65
        ];

        let actual = Torrent::from_bytes(&input);
        assert!(actual.is_err());
    }
}